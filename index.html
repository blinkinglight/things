<!doctype html>
<html>
  <head>
    <script type="text/javascript" src="van.js"></script>
    <script defer type="module">
      const {button, div, pre} = van.tags

      const sleep = ms => new Promise(resolve => setTimeout(resolve, ms))
      
      const Run = ({sleepMs}) => {
        const headingSpaces = van.state(40), trailingUnderscores = van.state(0)
      
        const animate = async () => {
          while (headingSpaces.val > 0) {
            await sleep(sleepMs)
            --headingSpaces.val, ++trailingUnderscores.val
          }
        }
        animate()
      
        const helloText = van.bind(headingSpaces, trailingUnderscores,
          (h, t) => `${" ".repeat(h)}🚐💨Hello VanJS!${"_".repeat(t)}`)
        return div(pre(helloText))  
      }
      
      const Hello = () => {
        const dom = div()
        return div(
          dom,
          button({onclick: () => van.add(dom, Run({sleepMs: 2000}))}, "Hello 🐌"),
          button({onclick: () => van.add(dom, Run({sleepMs: 500}))}, "Hello 🐢"),
          button({onclick: () => van.add(dom, Run({sleepMs: 100}))}, "Hello 🚶‍♂️"),
          button({onclick: () => van.add(dom, Run({sleepMs: 10}))}, "Hello 🏎️"),
          button({onclick: () => van.add(dom, Run({sleepMs: 2}))}, "Hello 🚀"),
        )
      }
      
      van.add(document.body, Hello())
    </script>
    <script defer type="module">
      // ES6 modules can be natively used by set the script type
      // to "module". Now we can use native imports.
      // import {
      //   connect,
      //   StringCodec,
      //   JSONCodec,
      // } from "https://cdn.jsdelivr.net/npm/nats.ws@1.10.0/esm/nats.js";

      // Initialize a string codec for encoding and decoding message data.
      // This is because NATS message data are just byte arrays, so proper
      // encoding and decoding needs to be performed when using the working
      // // with the message data.
      // // See also JSONCodec.
      // const sc = new StringCodec();
      // const jc = JSONCodec();
// 
      // // Establish a connection to the NATS demo server. This uses the
      // // native WebSocket support built into the NATS server.
      // const nc = await connect({
      //   servers: ["ws://localhost:4443"],
      // });
// 
      // // Subscribe to the "echo" subject and define a message
      // // handler that will respond to the requester.
      // const sub = nc.subscribe("abra");
      // const handle = (msg) => {
      //   console.log(`Received a request: ${sc.decode(msg.data)}`);
      //   document.getElementById("ws").innerHTML = sc.decode(msg.data);
      //   // msg.respond(msg.data);
      // }
// 
      // // Wait to receive messages from the subscription and handle them
      // // asynchronously..
      // (async () => {
      //   for await (const msg of sub) handle(msg)
      // })();
// 
      // // Now we can send a couple requests to that subject. Note how we
      // // are encoding the string data on request and decoding the reply
      // message data.
      //let rep = await nc.request("svc.post.create.command", sc.encode("Hello!"));
      //console.log(`Received a reply ok: ${sc.decode(rep.data)}`);

      // rep = await nc.request("svc.post.create.command", sc.encode("World!"));
      // console.log(`Received a reply: ${sc.decode(rep.data)}`);

      // Finally drain the connection which will handle any outstanding
      // messages before closing the connection.
      //nc.drain();
      let ws = new WebSocket("ws://localhost:3000/ws");
      ws.onopen = function() {
        console.log("open");
        // ws.send("hello");
      }
      ws.onmessage = function(e) {
        console.log("message", e.data);
        document.getElementById("ws").innerHTML = e.data;

        let json = JSON.parse(e.data);
        if(json.action) {
          switch(json.action) {
            case "add" :
              document.getElementById("ws").innerHTML = json.data;
              break;
          }
        }
        if(json.data) {

          if(json.data.command) {
            switch(json.data.command) {
              case "popup" :
              // document.getElementById("ws").innerHTML = json.data;
              alert(json.data.text);
              break;
            }
          }
        }
      }
      ws.onclose = function() {
        console.log("close");
      }
      ws.onerror = function() {
        console.log("error");
      }
      

      window.showpopup = async function() {
        ping({}, "svc.popup")
        .then((response) => {
          console.log(response);
          return response.json();
      }).then((data) => {
          console.log(data);
      }).catch((err) => {
          console.log(err);
      })
      }

      window.login2 = async function() {
        let payload = {
          data: {
            username: document.getElementById("username").value,
            password: document.getElementById("password").value,
          }
        }
        ping(payload, "svc.login")
        .then((response) => {
          console.log(response);
          return response.json();
      }).then((data) => {
          console.log(data);
          window.session_id = data.session_id;
          document.getElementById("response").innerHTML = JSON.stringify(data);
          if(data.success) {
              document.getElementById("loginform").style.display = "none";
              document.getElementById("logoutform").style.display = "block";
          }
          if(data.message) {
              document.getElementById("message").innerHTML = data.message;
          }
      }).catch((err) => {
          console.log(err);
      });
      }

      window.alive = async function () {
        let payload = {
          data: {
            session_id: window.session_id
          }
        }
        ping(payload, "svc.alive");
      }


      window.ping = async function(payload, fn) {
        return fetch(`http://localhost:3000/pipe?type=command&subject=${fn}&me=abra`, {
          method: "POST",
          body: JSON.stringify(payload),
          headers: {
              "Content-Type": "application/json"
          }
      });
      }
      
      
      window.send = async function(payload) {
        console.log("send", payload);
        let rep = await nc.request("svc.post.create.command", jc.encode(payload));
        console.log(`Received a reply ok: ${sc.decode(rep.data)}`);
      }
      window.login = async function() {
        let payload = {
            username: document.getElementById("username").value,
            password: document.getElementById("password").value,
        }
        let rep = await nc.request("svc.login", jc.encode(payload));
        let data = sc.decode(rep.data);
        console.log(`Received a reply ok: ${data}`);
        document.getElementById("response").innerHTML = data;
        data = JSON.parse(data);
        if(data.success) {
            document.getElementById("loginform").style.display = "none";
            document.getElementById("logoutform").style.display = "block";
        }
        if(data.message) {
            document.getElementById("message").innerHTML = data.message;
        }
      }
      window.logout = async function() {
        ping({session_id: window.session_id}, "svc.logout")
        .then((response) => {
          console.log(response);
          return response.json();
      }).then((data) => {
          console.log(data);
          window.session_id = data.session_id;
          document.getElementById("response").innerHTML = JSON.stringify(data);
          if(data.success) {
              document.getElementById("loginform").style.display = "block";
              document.getElementById("logoutform").style.display = "none";
          }
          if(data.message) {
              document.getElementById("message").innerHTML = data.message;
          }
      }).catch((err) => {
          console.log(err);
      })
        // let rep = await nc.request("svc.logout", jc.encode({}));
        // let data = sc.decode(rep.data);
        // console.log(`Received a reply ok: ${data}`);
        // document.getElementById("response").innerHTML = data;
        // data = JSON.parse(data);
        //if(data.success) {
        //    document.getElementById("loginform").style.display = "block";
        //    document.getElementById("logoutform").style.display = "none";
      //  }
        //if(data.message) {
         //   document.getElementById("message").innerHTML = data.message;
       // }
      }

      window.somethinglive = async function() {

      }
    </script>
    <div id="message">

    </div>
    <div id="response">

    </div>
    <div id="loginform">
        <input type="username" id="username" placeholder="username" />
        <input type="password" id="password" placeholder="password" />
        <button onclick="login2()">send</button>
        <button onclick="alive()">alive</button>
        <button onclick="showpopup()">popup</button>
    </div>
    <div id="logoutform" style="display:none">
        <button onclick="logout()">Logout</button>
    </div>

    <div id="ws">

    </div>
  </head>
</html>
